# Category为什么不能添加实例变量，但是可以添加方法？

这个问题，想必每一个iOS开发都被问到过，我曾经也喜欢闻别人这个问题，因为这个问题考察了runtime的很多概念，比如类对象，比如isa指针，结构体等等。我记得曾经听到最不走心的一个回答是：因为苹果就是这么设计的。当时把我给气的恨不得直接pass他。不过经过这么多年的学习和积累，我再重新回过头看这个问题，突然觉得这个不走心的回答，还真的是最接近我目前理解的答案。

关于这个问题，网上有很多说法，有说“已编译的类的内存布局是不变的，Class就是一个结构体，里面的成员不能改变”，这个答案其实误导性很高，并没有搞清楚类对象和实例对象的概念。复杂一些的，会抛出runtime的源码，说没办法通过代码添加实例变量。能通过看runtime源码去找到答案，我觉得很棒。但是这是从结论反推，我们更应该深入想想，为什么runtime不提供添加实例变量的方法呢？

为了能回答好这个问题，我们先回顾一下OC中类对象和实例对象的概念。我们编译期定义好的一个个类，在运行期其实也是内存中的一个数据结构，即一个结构体。通过这个结构体，我们可以生成实例对象，这些对象，实际上也是一个结构体。换句话说，所有的对象，在内存中都是以结构体的形式存在的。那么类对象和实例对象的关系之间有什么关系呢？我们可以看成是手机设计图和手机，手机设计图就是类对象，手机就是实例对象，可以通过手机设计图加工出手机。那么回到OC中，类对象的结构体中一定存放了生产实例对象相关的很多信息，比如需要分配多少内存，比如方法列表，成员变量列表，协议列表等。iOS的runtime，就是提供一些接口，在运行时动态的改变这些列表。既然方法列表、协议列表都是可以改变的，成员变量列表为什么不行呢？

这个问题我们可以通过现实中的一个例子来看。假设有一个手机工厂在运行期间，某一条产品线的同一批次手机根据同一张设计图生产手机，手机的硬件属性必然要求是一致的，你不能说，正在加工呢，你突然改了图纸的某个属性，前一台手机是1M内存，后一台成了2M，前一台双摄，后一台四摄，真的要改，肯定是要先停下生产，从新设计图纸，再开始加工。否则生产出来的产品层次不齐，肯定会出问题。再看类对象，如果我们在运行期肆意修改实例变量列表，那通过类对象前后生产出来的实例，内存布局都不一样，已经创建出的类实例就不符合类的定义，变成了无效对象。为了确保类对象生产出来的类实例内存结构一致，自然不能提供修改类对象成员变量列表。

再回到开头说的那个回答，实际上，并不是类对象的内存结构不能变，而是前后生产出来的实例对象内存结构要一致。

我们可以再想想，为什么runtime可以动态改方法列表呢？

因为方法并不“属于”类实例，成员变量是“属于”类实例的，一个实例，是通过其isa指针找到类对象，再通过方法列表找到对应的方法的，编译期写好的方法放在代码区，我们把分类里的代码添加到主类的方法列表里就行。这样并不会改变实例对象的内存结构。类对象的内存结构实际上也没有改变，只是方法列表里的内容发生了改变。

再看runtime源码，方法列表是放在class_rw_t中的，是一个可读写的数据结构，会把分类、协议中的方法都合并到一起。而实例变量列表是放在class_ro_t中的，只读。至于怎么让方法列表和实例变量列表满足各自要求，其实用不同的数据结构存储就可以了。比如方法列表的数据结构使用链表，可以增删改查，而成员变量列表是一个数组，只能查，不能增删改。

