#### 简述iOS的锁机制
多线程开发中，当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了数据竞争(Data race)。所以这是就要利用一些同步机制来确保数据的准确性，锁就是同步机制中的一种。

#####锁的基本概念：
* **临界区：**指的是一块对公共资源进行访问的代码，并非一种机制或是算法。
* **自旋锁：**是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种`忙等待`。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。
* **互斥锁（Mutex）：**是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。
*  **读写锁：**是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。
*  **信号量（semaphore）：**是一种更高级的同步机制，`互斥锁`可以说是semaphore在仅取值0/1时的特例。`信号量`可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。
* **条件锁：**条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。
* **递归锁：**同一个线程可以加锁N次而不会引发死锁的同步机制
#####iOS框架中的十一种常用锁：
* **NSLock**：互斥锁，是Foundation框架中以对象形式暴露给开发者
* **pthread_mutex**：互斥锁
* **@synchronized**：互斥锁
* **OSSpinLock**：自旋锁，在某一些场景下已经不安全了，使用较少
* **os_unfair_lock**：自选锁，苹果官方推荐的替换OSSpinLock的方案(iOS10+)
* **pthread_rwlock**：读写锁
* **NSRecursiveLock**：递归锁
* **pthread_mutex(recursive):**：递归锁，pthread_mutex的变形
* **NSCondition**：条件锁，需遵循NSLocking协议
* **NSConditionLock**：条件锁，基本同上
* **dispatch_semaphore**：信号量，GCD中的线程同步机制

 ---
